### ШРИ 2016 (Задание №2)
Описание задания можно посмотреть [здесь](https://academy.yandex.ru/events/frontend/shri_msk-2016/#test "Задание №2 Яндекс ШРИ 2016").

### Реализация задачи

Перед тем как начать писать библиотеку, я разобрал требуемый функционал и пришел к следующей структуре:

   * Будет четыре главных объекта: Студенты, Менторы, Группы, Задачи
   * У каждого объекта своя структура


```javascript
Студент {
    "id": 1,
    "name": "Имя студента",
    "groupId": 1,       //-> id группы, в которой состоит студент
    "tasksId": [],      //-> массив с id задач студента
    "wishList": [{      //-> список приоритетов
        "mentorId": 1,  //-> id ментора
        "priority": 4   //-> приоритет ментора
    }, {
        "mentorId": 2,
        "priority": 6
    }]
}
Ментор {
    "id": 1,
    "name": "Имя ментора",
    "list": [],         //-> массив с id распределенных студентов
    "wishList": [{      //-> список приоритетов
        "studentId": 1, //-> id студента
        "priority": 2   //-> приоритет студента
    }, {
        "studentId": 2,
        "priority": 10
    }
}
Группа {
    "id": 1,
    "name": "Имя группы",
    "studentsId": [1, 4, 6, 7], //-> массив id студентов, состоящих в данной группе
    "tasksId": [4]              //-> массив id задач группы
}
Задача {
    "id": 1,
    "name": "Наименование задачи",
    "details": "Описание задачи",
    "rating": 4,                //-> оценка задачи
    "studentId": 9,             //-> id студента, если задача индивидуальная
    "groupId": 0                //-> id группы, если задача групповая
}
```

   * Объекты будут взаимосвязаны. Если удаляется студент, то будут удалены задачи, связанные с ним, а также обновлен список студентов группы, в которую он входил.
   Получается мини БД со связанными элементами.
   
   * Данные приходят из .json файла.
   
   Далее реализовал функции, с помощью которых достигался необходимый функционал. В коде для каждой функции имеется коментарий.

#### Функция распределения студентов `sortStudents()`

Кратко опишу ход мыслей при реализации данной функции. 

Студенты и менторы могут ставить приоритеты друг другу. Значения приоритетов хранятся в объектах. Задача заключается в равномерном распределении студентов среди менторов, согласно спискам
приоритезации. Основная идея заключается в нахождении так называемой "синергии" между студентом и ментором, которая является суммой приоритетов, поставленных друг другу.

Таким образом, вычислив синергию между всеми студентами и менторами, создается массив из элементов следующего вида:

    array[[значение_синергии, id_ментора, id_студента],
          [значение_синергии, id_ментора, id_студента],
          ...]

Далее данный массив сортируется по убыванию значения синергии. В итоге мы получаем массив, в котором на первых местах стоят элементы с данными студентов и менторов, которые хотели попасть друг к другу больше всего.

Следующим этапом идет непосредственно распределение. Берется первый элемент массива, находится ментор по id, и к нему в список студентов заносится id студента. Поскольку данный студент уже попал к ментору, из массива удаляются все элементы,
содержащие id данного студента.

Также, если количество студентов в списек ментора достигнет максимума, элементы с его id также удаляются, чтобы к нему не попали "лишние" студенты.
Итогом работы данного распределения становятся списки студентов у каждого ментора. Распределение закончилось, результат выводится на экран.

### Веб-интерфейс для библиотеки

Для удобства использования библиотеки решил реализовать веб-интерфейс. Он состоит из: _списка задач_, _списка студентов/менторов_, причем в списке студентов отражаются также и _группы_, и _кнопки распределения студентов_.
Весь интерфейс построен на рендеринге шаблонов отдельных элементов. Например, возьмем студентов.

Для них есть контейнер `.students__list`. При вызове функции `showStudents()`, цикл пробегает по всем студентам и на основе шаблона создает элемент `.students__name`, который добавляется в контейнер. Таким образом
происходит отображение всех студентов. При каких либо изменениях, связанных со студентами, функция рендеринга запустится снова и выдаст обновленный результат. Аналогичным образом работают остальные функции рендеринга.